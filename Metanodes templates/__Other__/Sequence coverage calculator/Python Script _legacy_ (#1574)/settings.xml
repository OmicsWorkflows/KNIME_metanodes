<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
    <entry key="node_file" type="xstring" value="settings.xml"/>
    <config key="flow_stack"/>
    <config key="internal_node_subsettings">
        <entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
    </config>
    <config key="model">
        <entry key="sourceCode" type="xstring" value="import re%%00010import pandas%%00010%%00010def convert_to_regex(sequence):%%00010    # Define mappings for ambiguous amino acids%%00010    mappings = {%%00010        'X': '.',  # X can be any amino acid%%00010        'Z': '[QE]',  # Z can be Q or E%%00010        'B': '[DN]',  # B can be D or N%%00010        'J': '[LI]',  # J can be L or I%%00010    }%%00010%%00010    # Replace each ambiguous amino acid with its regex equivalent%%00010    regex_sequence = ''.join([mappings.get(aa, aa) for aa in sequence])%%00010    #print(regex_sequence)%%00010    return regex_sequence%%00010%%00010def calculate_coverage(protein_sequences, peptides):%%00010    protein_sequences = protein_sequences.split(flow_variables['top_sequences_delimiter'])%%00010    coverages = []%%00010%%00010    for protein_sequence in protein_sequences:%%00010        # Create a list of zeros with the length of the protein sequence%%00010        coverage = [0] * len(protein_sequence)%%00010%%00010        # Convert protein sequence to regex pattern%%00010        protein_sequence_regex = convert_to_regex(protein_sequence)%%00010        %%00010        # Mark the positions covered by the peptides%%00010        for peptide in peptides:%%00010            peptide_regex = convert_to_regex(peptide)%%00010            for match in re.finditer(peptide_regex, protein_sequence_regex):%%00010                start = match.start()%%00010                end = match.end()%%00010                for i in range(start, end):%%00010                    coverage[i] = 1%%00010%%00010        # calculate coverage as the fraction of covered positions%%00010        covered_positions = sum(coverage)%%00010        coverage_fraction = covered_positions / len(protein_sequence)%%00010%%00010        # append percentage coverage for each protein%%00010        coverages.append(round((coverage_fraction * 100), flow_variables['percentage_digits']))%%00010        # creates string version of the concatenated sequences for better compatibility with the output table%%00010        covergees_string = flow_variables['top_sequences_delimiter'].join(map(str, coverages)) %%00010%%00010    return covergees_string%%00010%%00010# Example usage%%00010#protein_sequences = &quot;MKTLLIALAVLPLSLRLSE;TLLAVLPQLRLSEMKTLL&quot;%%00010#peptides = [&quot;MKTXL&quot;, &quot;LPLS&quot;, &quot;LSE&quot;, &quot;JALAV&quot;]%%00010#coverages = calculate_coverage(protein_sequences, peptides)%%00010#for i, coverage in enumerate(coverages):%%00010#    print(f&quot;Protein sequence {i+1} coverage: {coverage:}%&quot;)%%00010%%00010%%00010#sequences = input_table_1['UniProt_Sequence'].tolist()%%00010peptides = input_table_2['Stripped.Sequence'].tolist()%%00010%%00010#creates empty list to store the found protein sequences%%00010coverages_column_list = []%%00010%%00010# go through each row value to check whether it is integer or not and converts it to Int if yes%%00010for sequence in input_table_1['UniProt_Sequence'].tolist():%%00010    coverages_column_list.append(calculate_coverage(sequence, peptides))%%00010#    if isinstance(row, float) and row.is_integer():%%00010#        data.append(int(row))%%00010#    else:%%00010#        data.append(row)%%00010%%00010output_table_1 = input_table_1%%00010%%00010output_table_1 = output_table_1.drop(output_table_1.columns[1], axis=1)%%00010%%00010output_table_1['sequence coverage'] = coverages_column_list%%00010%%00010# overwrites the original top table IDs column with the list of checked data%%00010#input_table_1[flow_variables['top_input_ids_column']] = data%%00010%%00010#output_table_1 = input_table_1"/>
        <entry key="rowLimit" type="xint" value="100"/>
        <entry key="convertMissingToPython" type="xboolean" value="false"/>
        <entry key="convertMissingFromPython" type="xboolean" value="false"/>
        <entry key="sentinelOption" type="xstring" value="MIN_VAL"/>
        <entry key="sentinelValue" type="xint" value="0"/>
        <entry key="chunkSize" type="xint" value="1000"/>
        <entry key="pythonVersionOption" type="xstring" value="python3"/>
        <entry key="python2Command" type="xstring" value=""/>
        <entry key="python3Command" type="xstring" value="/home/knimeuser/.pyenv/versions/4-5-2a/bin/python3"/>
    </config>
    <config key="variables">
        <entry key="version" type="xstring" value="V_2019_09_13"/>
        <config key="tree">
            <config key="python3Command">
                <entry key="used_variable" type="xstring" value="python3command"/>
                <entry key="exposed_variable" type="xstring" isnull="true" value=""/>
            </config>
        </config>
    </config>
    <config key="nodeAnnotation">
        <entry key="text" type="xstring" value="tries to convert the %%00010top table IDs to %%00010integer if possible"/>
        <entry key="bgcolor" type="xint" value="16777215"/>
        <entry key="x-coordinate" type="xint" value="889"/>
        <entry key="y-coordinate" type="xint" value="599"/>
        <entry key="width" type="xint" value="142"/>
        <entry key="height" type="xint" value="48"/>
        <entry key="alignment" type="xstring" value="CENTER"/>
        <entry key="borderSize" type="xint" value="0"/>
        <entry key="borderColor" type="xint" value="16777215"/>
        <entry key="defFontSize" type="xint" value="10"/>
        <entry key="annotation-version" type="xint" value="20151123"/>
        <config key="styles"/>
    </config>
    <entry key="customDescription" type="xstring" isnull="true" value=""/>
    <entry key="state" type="xstring" value="CONFIGURED"/>
    <entry key="factory" type="xstring" value="org.knime.python2.nodes.script2.Python2ScriptNodeFactory2"/>
    <entry key="node-name" type="xstring" value="Python Script (legacy)"/>
    <entry key="node-bundle-name" type="xstring" value="KNIME Python nodes"/>
    <entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.python2.nodes"/>
    <entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
    <entry key="node-bundle-version" type="xstring" value="4.7.0.v202211291448"/>
    <entry key="node-feature-name" type="xstring" value="KNIME Python 2 Integration (legacy)"/>
    <entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.python2.feature.group"/>
    <entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
    <entry key="node-feature-version" type="xstring" value="4.7.1.v202301311311"/>
    <config key="factory_settings"/>
    <config key="node_creation_config">
        <config key="Input object (pickled)"/>
        <config key="Input table">
            <config key="port_0">
                <entry key="object_class" type="xstring" value="org.knime.core.node.BufferedDataTable"/>
            </config>
            <config key="port_1">
                <entry key="object_class" type="xstring" value="org.knime.core.node.BufferedDataTable"/>
            </config>
        </config>
        <config key="Output table">
            <config key="port_0">
                <entry key="object_class" type="xstring" value="org.knime.core.node.BufferedDataTable"/>
            </config>
        </config>
        <config key="Output image"/>
        <config key="Output object (pickled)"/>
    </config>
    <entry key="name" type="xstring" value="Python Script (legacy)"/>
    <entry key="hasContent" type="xboolean" value="false"/>
    <entry key="isInactive" type="xboolean" value="false"/>
    <config key="ports">
        <config key="port_1">
            <entry key="index" type="xint" value="1"/>
            <entry key="port_dir_location" type="xstring" isnull="true" value=""/>
        </config>
    </config>
    <config key="filestores">
        <entry key="file_store_location" type="xstring" isnull="true" value=""/>
        <entry key="file_store_id" type="xstring" isnull="true" value=""/>
    </config>
</config>
